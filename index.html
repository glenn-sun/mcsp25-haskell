<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>Title</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/theme/simple.css" id="theme">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=open_in_new" />
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <div class="vertical-center">
          <h1>Monads, Categories, and<br>the Structure of Programming</h1>
          <p class="center"><br>Mathcamp 2025</p>
          <p class="center">Glenn Sun</p>
          <p class="center"><br><em>These slides may contain errors,<br> and should not be considered an authorative source.</em></p>
        </div>
      </section>

      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
        </div>
      </section>

      <section>
        <div class="vertical-center">
          <a href="https://ncatlab.org/nlab/show/carrying" target="_blank">nLab: carrying <span class="material-symbols-outlined">
            open_in_new
          </span></a>
        </div>
      </section>

      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
          <p class="center">____________ is ________________ for ___________________.</p>
        </div>
      </section>
      <section>
        <div class="vertical-center">
          <p>In Java, is <code class="tt">List</code> a type?</p>
          <p class="answer fragment" data-fragment-index="1">No, but <code class="tt">List&lt;T&gt;</T></code> is for any type <code class="tt">T</code>.</p>
          <p>In C++, is <code class="tt">std::vector</code> a type?</p>
          <p class="answer fragment" data-fragment-index="1">No, but <code class="tt">std::vector&lt;T&gt;</T></code> is for any type <code class="tt">T</code>.</p>
        </div>
      </section>

      <section>
        <h2 class="center">endofunctor $\longleftrightarrow$ type constructor</h2>
        <p>In Java, examples of type constructors include:</p>
        <ul>
          <li><code class="tt">List</code> (which produces types <code class="tt">List&lt;T&gt;</code>)</li>
          <li><code class="tt">Map</code> (which produces types <code class="tt">Map&lt;K, V&gt;</code>)</li>
          <li><code class="tt">Set</code> (which produces types <code class="tt">Set&lt;T&gt;</code>)</li>
        </ul>
        <p>In C++, examples of type constructors include:</p>
        <ul>
          <li><code class="tt">std::vector</code> (which produces types <code class="tt">std::vector&lt;T&gt;</code>)</li>
          <li><code class="tt">std::map</code> (which produces types <code class="tt">std::map&lt;K, V&gt;</code>)</li>
          <li><code class="tt">std::set</code> (which produces types <code class="tt">std::set&lt;T&gt;</code>)</li>
        </ul>
      </section>

      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
          <p class="center">____________ is ________________ for type constructors.</p>
        </div>
      </section>

      <section>
        <h2 class="center">monad $\longleftrightarrow$ type constructor with <em>flattening</em></h2>
        <p class="center">Canonical example: lists</p>
        <pre class="fragment" data-fragment-index="1"><code data-trim class="language-text">
          [[1, 2, 3], 
           [4, 5, 6], 
           [7, 8, 9]]
        </code></pre>
        <p class="center fragment" data-fragment-index="2">$\downarrow$</p>
        <pre class="fragment" data-fragment-index="2"><code data-trim class="language-text">
          [1, 2, 3, 4, 5, 6, 7, 8, 9]
        </code></pre>
      </section>

      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
          <p class="center">Flattening is ________________ for type constructors.</p>
        </div>
      </section>

      <section>
        <h2 class="center">monoid $\longleftrightarrow$ <em>type</em> with <em>concatenation</em></h2>
        <ul>
          <li class="fragment" data-fragment-index="1">Lists 
            <pre><code data-trim class="language-text">
              [1, 2, 3] ++ [4, 5, 6] == [1, 2, 3, 4, 5, 6]
            </code></pre>
          </li>
          <li class="fragment" data-fragment-index="2">Strings 
            <pre><code data-trim class="language-text">
              "hello" ++ "world" == "helloworld"
            </code></pre>
          </li>
          <li class="fragment" data-fragment-index="3">Natural numbers (concatenation in unary) 
            <pre><code data-trim class="language-text">
              3 ++ 5 == 8
            </code></pre>
          </li>
        </ul>
      </section>  
      
      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
          <p class="center">Flattening is concatenation of type constructors.</p>
        </div>
      </section>

      <section>
        <h2>Concatenation of type constructors</h2>
        <p>Concatenation of lists has type signature: $$\pplus : \texttt{List&lt;T&gt;} \times \texttt{List&lt;T&gt;} \to \texttt{List&lt;T&gt;}$$ </p>
        <p>Concatenation of the <em>type constructor</em> <code class="tt">List</code> has type signature: $$\pplus : \texttt{List&lt;List&lt;T&gt;&gt;}\to \texttt{List&lt;T&gt;} $$</p>
        <p>This is flattening!</p>
      </section>

      <section>
        <h2>Outline</h2>
        <p>Up next: What are monads and why are they useful?</p>
        <p>Later: More about categories and monoids</p>
      </section>

      <section>
        <div class="vertical-center">
          <p>In your favorite language, are the following two pieces of code equivalent (ignoring differences in running time) for any function $f : \texttt{int} \to \texttt{int}$? </p>
          <ol>
            <li><code class="tt">f(x) + f(x)</code></li>
            <li><code class="tt">f(x) * 2</code></li>
          </ol>
          <p class="answer fragment" data-fragment-index="1">No, consider the following code.</p>
          <pre class="fragment" data-fragment-index="1"><code data-trim class="language-java">
            public static int f(int x) {
              System.out.println("User executed f");
              return x + 1;
            }
          </code></pre>
        </div>
      </section>

      <section>
        <h2>Pure functions</h2>
        <p>A <em>pure</em> function is <em>deterministic</em> and has no <em>side effects</em>.</p>
        <p class="fragment">Side effects change the state of the system outside the function.</p>
        <ul class="fragment">
          <li>Input and output</li>
          <li>File system access</li>
          <li>Throwing exceptions</li>
          <li>Global variables</li>
          <li>Mutable function parameters</li>
        </ul>
      </section>

      <section>
        <h2>Functional programming</h2>
        <p><em>Functional programming</em> is a style that focuses on:</p>
        <ul>
          <li>Pure functions</li>
          <li class="fragment" data-fragment-index="1">Immutable data</li>
          <li class="fragment" data-fragment-index="2">Declarative, not imperative code</li>
          <pre class="fragment" data-fragment-index="2"><code data-trim class="language-python">
            def odd_squares(arr):
              return (arr.filter(lambda x: x % 2 == 1)
                         .map(lambda x: x ** 2))
          </code></pre>
        </ul>
        <p class="fragment" data-fragment-index="3">Functional programming should <em>feel like mathematics</em>.</p>
      </section>

      <section>
        <h2>Functional programming</h2>
        <p>People like functional programming.</p>
        <p class="fragment">Some languages are designed for it: Excel, Mathematica, Haskell</p>
        <p class="fragment">How do these languages handle side effects?</p>
        <ul>
          <li class="fragment">Excel/Mathematica: Give up on being functional languages</li>
          <li class="fragment">Haskell: Use monads!</li>
        </ul>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>Haskell uses mathematical notation for function definitions.</p>
        <p>Function application does not require parentheses.</p>
        <pre><code data-trim class="language-haskell">
          f :: Int -> Int
          f x = x + 1
        </code></pre>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>Just like in math, Haskell makes it easy to compose functions.</p>
        <pre><code data-trim class="language-haskell">
          f :: Int -> Int
          f x = x + 1

          g :: Int -> Int
          g x = x * 2

          h :: Int -> Int
          h = f . g
        </code></pre>        
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>There is a built-in identity function.</p>
        <p>It works with all types.</p>
        <p>In Haskell, we usually write <code class="tt">a</code>, <code class="tt">b</code>, etc. for generic types.</p>
        <pre><code data-trim class="language-haskell">
          id :: a -> a
          id x = x
        </code></pre>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>Haskell supports <em>pattern matching</em> in function definitions.</p>
        <pre><code data-trim class="language-haskell">
          fib :: Int -> Int
          fib 0 = 0
          fib 1 = 1
          fib n = fib (n - 1) + fib (n - 2)
        </code></pre>
        <p>(This code is not perfectly safe, it enters an infinite loop for negative values of <code class="tt">n</code>.)</p>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>You can also define functions on multiple variables.</p>
        <p>The type <code class="tt">Int -> Int -> Int</code> means <code class="tt">Int -> (Int -> Int)</code>.</p>
        <pre><code data-trim class="language-haskell">
          gcd :: Int -> Int -> Int
          gcd n 0 = n
          gcd n m = gcd m (n `mod` m)
        </code></pre>
        <p>In other words, after this definition, Haskell considers <code class="tt">gcd n</code> to be a perfectly good function with type <code class="tt">Int -> Int</code>.</p>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>Pattern matching is especially powerful for <em>algebraic data types</em>.</p>
        <pre><code data-trim class="language-haskell">
          data Shape = Circle Float | Rectangle Float Float

          area :: Shape -> Float
          area (Circle r) = pi * r * r
          area (Rectangle l w) = l * w
        </code></pre>
        <p class="fragment">In math, this is the type $\mathbb{R} + (\mathbb{R} \times \mathbb{R})$.</p>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>A <code class="tt">List</code> is a <em>recursive</em> algebraic data <em>type constructor</em>.</p>
        <pre><code data-trim class="language-haskell">
          data List a = Empty | Nonempty a (List a)

          len :: List a -> Int
          len Empty = 0
          len (Nonempty x l) = 1 + len l
        </code></pre>
        <p class="fragment">In math, we write $L(a) = 1 + (a \times L(a))$.
      </section>

      <section>
        <div class="vertical-center">
          <p>What happens when you execute the following in Java?</p>
          <pre><code data-trim class="language-java">
            List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
            System.out.println(arr.get(0));
          </code></pre>
          <p class="answer fragment" data-fragment-index="1">Throws an <code class="tt">IndexOutOfBoundsException</code>.</p>
          <pre class="fragment" data-fragment-index="2"><code data-trim class="language-java">
            List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
            System.out.println(arr.indexOf(6));
          </code></pre>
          <p class="answer fragment" data-fragment-index="3">Prints <code class="tt">-1</code> (a sentinel value).</p>
        </div>
      </section>

      <section>
        <h2>The <code class="tt">Maybe</code> type constructor</h2>
        <p>(Also called <code class="tt">Optional</code> in other languages.)</p>
        <pre><code data-trim class="language-haskell">
          data Maybe a = Nothing | Just a

          peek :: List a -> Maybe a
          peek Empty = Nothing
          peek (Nonempty x l) = Just x
        </code></pre>
        <p class="fragment">In other languages, we would likely have <code class="tt">peek :: List a -> a</code> and it would either throw an exception or return a sentinel value.</p>
      </section>

      <section>
        <h2>The <code class="tt">Writer</code> type constructor</h2>
        <p><code class="tt">Writer</code> allows you to collect text to print to the console.</p>
        <pre><code data-trim class="language-haskell">
          data Writer a = Writer a String

          addone :: Int -> Writer Int
          addone x = Writer (x + 1) "User added one. "
        </code></pre>
        <p>Although it seems trivial right now (just a fancy name for a tuple), it will become important later.</p>
      </section>

      <section>
        <h2>The <code class="tt">IO</code> type constructor</h2>
        <p>This built-in type constructor is used whenever the console is used to get input or display output.</p>
        <p><code class="tt">IO a</code> means an I/O operation that returns a value of type <code class="tt">a</code>.</p>
        <pre><code data-trim class="language-haskell">
          putStrLn :: String -> IO ()
          getLine :: IO String
        </code></pre>
        <p>Note that <code class="tt">getLine</code> is not a function!</p>
      </section>

      <section>
        <h2>Where we are</h2>
        <p>We learned about the type constructors:</p>
        <ul>
          <li><code class="tt">List</code></li>
          <li><code class="tt">Maybe</code></li>
          <li><code class="tt">Writer</code></li>
          <li><code class="tt">IO</code></li>
        </ul>
        <p>Secretly, these are all monads! That means we need to show how they <em>implement flattening</em>.</p>
        <p>Next up: Different types that implement the same functions.</p>
      </section>

      <section>
        <h2>Type classes</h2>
        <p>Type classes outline functionality that many types should share.</p>

        <p>Eventually, we'll define the <code class="tt">Monad</code> type class.</p>
        <pre><code data-trim class="language-haskell">
          class Show a where
            show :: a -> String
          
          print :: Show a => a -> IO ()
          print x = putStrLn (show x)
        </code></pre>
        </p>
      </section>

      <section>
        <h2>Type classes</h2>
        <p>We can implement the functions in a type class for various types.</p>
        <pre><code data-trim class="language-haskell">
          instance Show a => Show (List a) where
            show Empty = ""
            show (Nonempty x Empty) = show x
            show (Nonempty x l) = show x ++ ", " ++ show l
          
          main :: IO ()
          main = print (Nonempty 3 (Nonempty 8 Empty))
        </code></pre>
      </section>

      <section>
        <h2>Functors</h2>
        <p>We defined earlier that endofunctors are just type constructors.</p>
        <p>Formally, an (endo)functor must also be an instance of the <code class="tt">Functor</code> type class.</p>
        <pre><code data-trim class="language-haskell">
          class Functor F where
            fmap :: (a -> b) -> F a -> F b
        </code></pre>
        <p>The meaning of <code class="tt">fmap f</code> is that it applies <code class="tt">f</code> to each element inside the container.</p>
      </section>

      <section>
        <h2>Functors</h2>
        <pre><code data-trim class="language-haskell">
          instance Functor Maybe where
            fmap f Nothing = Nothing
            fmap f (Just x) = Just (f x)
        </code></pre>
        <div class="column">
          <div class="fragment" data-fragment-index="1"><span><code class="tt">f</code> ❤️ <code class="tt">x</code></span></div>
          <div class="divider fragment" data-fragment-index="2"></div>
          <div class="fragment" data-fragment-index="2"><span><code class="tt">f</code> 😢</span><span class="small-box"><code class="tt">x</code></span></div>
          <div class="divider fragment" data-fragment-index="3"></div>
          <div class="fragment" data-fragment-index="3"><span><code class="tt">fmap</code> 🤝 <code class="tt">f</code></span><span class="small-box"><code class="tt">x</code></span></div>
          <div class="divider fragment" data-fragment-index="4"></div>
          <div class="fragment" data-fragment-index="4"><span class="small-box"><span><code class="tt">f</code> ❤️ <code class="tt">x</code></span></span></div>
        </div> 
      </section>

      <section>
        <h2>Functors</h2>
        <pre><code data-trim class="language-haskell">
          instance Functor Writer where
            fmap f (Writer x s) = Writer (f x) s
        </code></pre>
        <pre class="fragment"><code data-trim class="language-haskell">
          instance Functor List where
            fmap f Empty = Empty
            fmap f (Nonempty x l) = Nonempty (f x) (fmap f l)
        </code></pre>
      </section>

      <section>
        <h2>When <code class="tt">fmap</code> is not enough</h2>
        <p>Imagine that <code class="tt">f</code> wants to change <code class="tt">x</code> into <code class="tt">y</code> and put it in a box, but <code class="tt">x</code> is already in 2 boxes. One option is:</p> 
        <div class="column overlap">
          <div class="fragment fade-in-then-out" data-fragment-index="1">
            <span><code class="tt">f</code> 😭</span>
            <span class="big-box"><span class="box">
              <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="2">
            <span><code class="tt">fmap</code> 🤝 <code class="tt">f</code></span>
            <span class="big-box"><span class="box">
              <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="3">
            <span class="big-box">
              <span><code class="tt">f</code> 😢</span> 
              <span class="box">
                <code class="tt">x</code>
              </span>
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="4">
            <span class="big-box">
              <span><code class="tt">fmap</code> 🤝 <code class="tt">f</code></span> 
              <span class="box">
                <code class="tt">x</code>
              </span>
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="5">
            <span class="big-box"><span class="box">
              <code class="tt">f</code> 😈 <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in" data-fragment-index="6">
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">y</code>
                </span>
              </span>
            </span>
          </div>
        </div>
        <p class="fragment" data-fragment-index="7">But the next time, <code class="tt">f</code> will have to get help from <code class="tt">fmap</code> 3 times!</p>
      </section>

      <section>
        <h2>Monads</h2>
        <p>A monad is a functor that also supports flattening. Formally,</p>
        <pre><code data-trim class="language-haskell">
          class Functor m => Monad m where
            join :: m (m a) -> m a
            return :: a -> m a
        </code></pre>
        <p>Haskell prefers the word <code class="tt">join</code> over <code class="tt">flatten</code>, but the meaning is the same. </p>
        <p>The function <code class="tt">return</code> is less important, it just puts a value into the container.</p>
      </section>

      <section>
        <h2>The <code class="tt">Maybe</code> monad</h2>
        <pre><code data-trim class="language-haskell">
          instance Monad Maybe where
            join (Just (Just x)) = Just x
            -- Nothing cases omitted
            return x = Just x
        </code></pre>

        <div class="column overlap">
          <div class="fragment fade-in-then-out" data-fragment-index="1">
            <span><code class="tt">f</code> 😭</span>
            <span class="big-box"><span class="box">
              <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="2">
            <span><code class="tt">join</code> ✨</span>
            <span class="big-box"><span class="box">
              <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="3">
            <span class="box">
              <code class="tt">x</code>
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="4">
            <span><code class="tt">fmap</code> 🤝 <code class="tt">f</code></span> 
            <span class="box">
              <code class="tt">x</code>
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="5">
            <span class="box">
              <code class="tt">f</code> 😈 <code class="tt">x</code>
            </span>
          </div>

          <div class="fragment fade-in" data-fragment-index="6">
            <span class="box"><span class="small-box">
              <code class="tt">y</code> 
            </span></span>
          </div>
        </div>

        <p class="fragment" data-fragment-index="7">In code, we can now do <code class="tt">fmap f . join</code>.</p>
      </section>


      <section>
        <h2>The <code class="tt">Writer</code> monad</h2>
        <pre><code data-trim class="language-haskell">
          instance Monad Writer where
            join (Writer (Writer x s1) s2) = Writer x (s1 ++ s2)
            return x = Writer x ""
        </code></pre>
        <div class="column">
          <div class="fragment" data-fragment-index="1">
            <span><code class="tt">join</code> ✨</span>
            <span class="box"><span class="small-box">
              <code class="tt">x</code> 📕
            </span>📗</span>
          </div>

          <div class="divider fragment" data-fragment-index="2"></div>

          <div class="fragment" data-fragment-index="2">
            <span class="small-box">
              <code class="tt">x</code> 📕 📗
            </span>
          </div>
        </div>
      </section>

      <section>
        <h2>The <code class="tt">Writer</code> monad</h2>
        <pre><code data-trim class="language-haskell">
          f :: Int -> Writer Int
          f x = Writer (x + 1) "Applied f. "

          g :: Int -> Writer Int
          g x = Writer (x * 2) "Applied g. "

          h :: Int -> Writer Int
          h x = Writer (x - 1) "Applied h. "
        </code></pre>
        <p>We want the "composition" <code class="tt">f . g . h</code>, but that is not possible.</p>
      </section>

      <section>
        <h2>The <code class="tt">Writer</code> monad</h2>
        <p>Instead, we can use <code class="tt">fmap</code> and <code class="tt">join</code>!</p>
        <pre><code data-trim class="language-haskell">
          composed :: Int -> Writer Int
          composed = join . fmap f . join . fmap g . h
        </code></pre>
        <p class="fragment" data-fragment-index="1">Haskell provides a <em>reverse fish</em> operator to make this more concise:</p>
        <pre class="fragment" data-fragment-index="1"><code data-trim class="language-haskell">
          (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
          f <=< g = join . fmap f . g 
          composed = f <=< g <=< h
        </code></pre>
      </section>

      <section>
        <h2>The <code class="tt">Writer</code> monad</h2>
        <p>Reverse fish composition fulfills the same need as standard composition with side effects, but remains pure. Recall that:</p>
        <pre><code data-trim class="language-haskell">
          f x = Writer (x + 1) "Applied f. "
          g x = Writer (x * 2) "Applied g. "
          h x = Writer (x - 1) "Applied h. "
        </code></pre>
        <p>Then <code class="tt">f <=< g <=< h</code> is equivalent to:</p>
        <pre class="fragment"><code data-trim class="language-haskell">
          composed x = Writer (((x - 1) * 2) + 1) 
                       "Applied f. Applied g. Applied h. "
        </code></pre>
      </section>

      <section>
        <h2><code class="tt">do</code> notation</h2>
        <p>Another way to use monads in Haskell is <code class="tt">do</code> notation.</p>
        <pre><code data-trim class="language-haskell">
          composed :: Int -> Writer Int
          composed x = do
            y1 <- h x 
            y2 <- g y1 
            y3 <- f y2
            return y3 
        </code></pre>
        <p>Superficially, it now looks a lot like other languages!</p>
      </section>

      <section>
        <h2><code class="tt">do</code> notation</h2>
        <p>To explain <code class="tt">do</code> notation, you will will first need to understand <em>lambda functions</em>.</p>

        <p>A lambda function is just an unnamed function. It has the following syntax:</p>

        <pre><code data-trim class="language-haskell">
          squareAll :: List Int -> List Int
          squareAll list = fmap (\x -> x * x) list
        </code></pre>
      </section>

      <section>
        <h2><code class="tt">do</code> notation</h2>
        <p>Let <code class="tt">f :: a -> m a</code> for some <code class="tt">Monad m</code> and type <code class="tt">a</code>. Then,</p>
        <pre><code data-trim class="language-haskell">
          g x = do
            y <- f x
            ...
        </code></pre>
        <p>is defined to mean:</p>
        <pre><code data-trim class="language-haskell">
          g = ((\y -> ...) <=< f)
        </code></pre>
      </section>

      <section>
        <h2><code class="tt">do</code> notation</h2>
        <pre><code data-trim class="language-haskell">
          h x = do
            y <- f x
            z <- g y
            return z
        </code></pre>
        <pre><code data-trim class="language-haskell">
          h = (\y -> ((\z -> return z) <=< g) y) <=< f
            = (\y -> (return <=< g) y) <=< f
            = return <=< g <=< f
            = g <=< f
        </code></pre>
      </section>

      <section>
        <h2><code class="tt">do</code> notation in I/O</h2>
        <pre><code data-trim class="language-haskell">
          main = do
            print "Enter name:"
            name <- getLine
            print ("Hello, " ++ name)
        </code></pre>

        <pre><code data-trim class="language-haskell">
          main = ((\_ -> (
                    (\name -> 
                      print ("Hello, " ++ name)
                    ) <=< (\_ -> getLine)) ()
                  ) <=< (\_ -> print "Enter name:")) ()
        </code></pre>
      </section>

      <section>
        <h2>Where we are</h2>
        <p>We learned about functors and monads.</p>
        <ul>
          <li><code class="tt">fmap</code> helps functions jump into containers</li>
          <li><code class="tt">join</code> flattens out nested containers</li>
          <li>Monads capture side effects</li>
          <li><code class="tt"><=<</code> and <code class="tt">do</code> make it easy to compose monadic functions</li>
        </ul>
        <p class="fragment">Next up: categories and monoids</p>
      </section>

      <section>
        <h2>Functor laws</h2>
        <p>Our  <em>category</em> is called <code class="tt">*</code> (all types). We said that an (endo)functor is a type constructor <code class="tt">F :: * -> *</code> that supports <code class="tt">fmap</code>.</p>

        <p class="fragment" data-fragment-index="1">Formally, <code class="tt">fmap</code> must also satisfy the following:</p>
        <ul class="fragment" data-fragment-index="1">
          <li>Identity law: </li>
          <div class="center"><code class="tt">fmap id == id</code></div>
          <li>Composition law: If <code class="tt">h == f . g</code>, then</li>
          <div class="center"> <code class="tt">fmap h == fmap f . fmap g</code></div>
        </ul>
        
      </section>

      <section>
        <h2>Monad laws</h2>
        <p>Monads are required to satisfy:</p>
        <ul>
          <li>Identity laws (acting on <code class="tt">m a</code>):
            <ul>
              <li>Box from outside: <code class="tt">join . return == id</code></li>
              <div class="column overlap">
                <div class="fragment fade-in-then-out" data-fragment-index="1">
                  <span class="box">
                    <code class="tt">x</code> 📕
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="2">
                  <span><code class="tt">return</code> 😈</span>
                  <span class="box">
                    <code class="tt">x</code> 📕
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="3">
                  <span class="big-box">
                    <span class="box">
                      <code class="tt">x</code> 📕
                    </span>
                  </span>
                </div>
                
                <div class="fragment fade-in-then-out" data-fragment-index="4">
                  <span><code class="tt">join</code> ✨ </span>
                  <span class="big-box">
                    <span class="box">
                      <code class="tt">x</code> 📕
                    </span> 
                  </span>
                </div>

                <div class="fragment fade-in" data-fragment-index="5">
                  <span class="box">
                    <code class="tt">x</code> 📕
                  </span>
                </div>
              </div>
              <li class="fragment fade-in" data-fragment-index="6">Box from inside: <code class="tt">join . fmap return == id</code></li>
            </ul>
          </li>
        </ul>
      </section>

      <section>
        <h2>Monad laws</h2>
        <p>Monads are required to satisfy:</p>
        <ul>
          <li>Identity laws (acting on <code class="tt">m a</code>):
            <ul>
              <li>Box from outside: <code class="tt">join . return == id</code></li>
              <li>Box from inside: <code class="tt">join . fmap return == id</code></li>
              <div class="column overlap">
                <div class="fragment fade-in-then-out" data-fragment-index="1">
                  <span class="box">
                    <code class="tt">x</code> 📕
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="2">
                  <span><code class="tt">fmap</code> 🤝 <code class="tt">return</code></span>
                  <span class="box">
                    <code class="tt">x</code> 📕
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="3">
                  <span class="box">
                    <span><code class="tt">return</code> 😈 <code class="tt">x</code> 📕</span>
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="4">
                  <span class="box">
                    <span class="small-box">
                      <code class="tt">x</code> 📕
                    </span>
                  </span>
                </div>
                
                <div class="fragment fade-in-then-out" data-fragment-index="5">
                  <span><code class="tt">join</code> ✨ </span>
                  <span class="box">
                    <span class="small-box">
                      <code class="tt">x</code> 📕
                    </span>
                  </span>
                </div>
                
                <div class="fragment fade-in-then-out" data-fragment-index="6">
                  <span class="small-box">
                    <code class="tt">x</code> 📕
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="6">
                  <span class="big-box" style="visibility: hidden;"></span>
                </div>
              </div>
            </ul>
          </li>
        </ul>
      </section>

      <section>
        <h2>Monad laws</h2>
        <ul>
          <li>Associativity law (acting on <code class="tt">m (m (m a))</code>): </li>
          <div class="center"><code class="tt">join . join == join . fmap join </code></div>
        </ul>
        <div class="column overlap">
          <div class="fragment fade-in-then-out" data-fragment-index="1">
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> 📕
                </span> 📗
              </span> 📘
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="2">
            <span><code class="tt">join</code> ✨ </span>
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> 📕
                </span> 📗
              </span> 📘
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="3">
            <span class="box">
              <span class="small-box">
                <code class="tt">x</code> 📕
              </span> 📗 📘
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="4">
            <span><code class="tt">join</code> ✨ </span>
            <span class="box">
              <span class="small-box">
                <code class="tt">x</code> 📕
              </span> 📗 📘
            </span>
          </div>
          
          <div class="fragment fade-in-then-out" data-fragment-index="5">
            <span class="small-box">
              <code class="tt">x</code> 📕 📗 📘
            </span>
          </div>
          
          <div class="fragment fade-in-then-out" data-fragment-index="6">
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> 📕
                </span> 📗
              </span> 📘
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="7">
            <span><code class="tt">fmap</code> 🤝 <code class="tt">join</code></span>
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> 📕
                </span> 📗
              </span> 📘
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="8">
            <span class="big-box">
              <span><code class="tt">join</code> ✨ </span>
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> 📕
                </span> 📗
              </span> 📘
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="9">
            <span class="big-box">
                <span class="small-box">
                  <code class="tt">x</code> 📕 📗
              </span> 📘
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="10">
            <span><code class="tt">join</code> ✨ </span>
            <span class="big-box">
                <span class="small-box">
                  <code class="tt">x</code> 📕 📗
              </span> 📘
            </span>
          </div>

          <div class="fragment fade-in" data-fragment-index="11">
            <span class="small-box">
              <code class="tt">x</code> 📕 📗 📘
            </span> 
          </div>
        </div>

        <p class="fragment center" data-fragment-index="12">"Joining outer first is the same as joining inner first."</p>
      </section>

      <section>
        <h2>Monoid laws</h2>
        <p>The monoid laws are exactly the same as the monad laws, with outside/inside replace with left/right!</p>
        <pre><code data-trim class="language-haskell">
          class Monoid m where
            (++) :: m -> m -> m
            empty :: m
        </code></pre>
        <ul>
          <li>Identity laws: <code class="tt">empty ++ x == x</code> and<code class="tt">x ++ empty == x</code></li>
          <li>Associativity law: <code class="tt">(x ++ y) ++ z == x ++ (y ++ z)</code></li>
        </ul>
      </section>

      <section>
        <h2>Final takeaways</h2>
        <ul>
          <li>Functional programming languages have functions return monadic types instead of producing side effects.</li>
          <li>The structure of a monad lets you easily compose such functions.</li>
          <li>Monoids in the category of endofunctors is a correct but terrible definition.</li>
        </ul>
      </section>
    </div>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/reveal.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/plugin/math/math.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/plugin/markdown/markdown.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/highlight/highlight.js"></script>

  <script>
    Reveal.initialize({
      controls: false,
      controlsTutorial: false,
      transition: 'fade',
      plugins: [RevealMath.KaTeX, RevealMarkdown, RevealHighlight],
      width: 1800,
      height: 1080,
      history: true,
      slideNumber: true,
      katex: {
        macros: {
          "\\pplus": "+\\!\\!+",
        }
      }
      
    });

  </script>

</body>

</html>