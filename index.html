<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>Title</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/theme/simple.css" id="theme">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=open_in_new" />
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <div class="vertical-center">
          <h1>Monads, Categories, and<br>the Structure of Programming</h1>
          <p class="center"><br>Mathcamp 2025</p>
          <p class="center">Glenn Sun</p>
        </div>
      </section>

      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
        </div>
      </section>

      <section>
        <div class="vertical-center">
          <a href="https://ncatlab.org/nlab/show/carrying" target="_blank">nLab: carrying <span class="material-symbols-outlined">
            open_in_new
          </span></a>
        </div>
      </section>

      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
          <p class="center">____________ is ________________ for ___________________.</p>
        </div>
      </section>
      <section>
        <div class="vertical-center">
          <p>In Java, is <code class="tt">List</code> a type?</p>
          <p class="answer fragment" data-fragment-index="1">No, but <code class="tt">List&lt;T&gt;</T></code> is for any type <code class="tt">T</code>.</p>
          <p>In C++, is <code class="tt">std::vector</code> a type?</p>
          <p class="answer fragment" data-fragment-index="1">No, but <code class="tt">std::vector&lt;T&gt;</T></code> is for any type <code class="tt">T</code>.</p>
        </div>
      </section>

      <section>
        <h2 class="center">endofunctor $\longleftrightarrow$ type constructor</h2>
        <p>In Java, examples of type constructors include:</p>
        <ul>
          <li><code class="tt">List</code> (which produces types <code class="tt">List&lt;T&gt;</code>)</li>
          <li><code class="tt">Map</code> (which produces types <code class="tt">Map&lt;K, V&gt;</code>)</li>
          <li><code class="tt">Set</code> (which produces types <code class="tt">Set&lt;T&gt;</code>)</li>
        </ul>
        <p>In C++, examples of type constructors include:</p>
        <ul>
          <li><code class="tt">std::vector</code> (which produces types <code class="tt">std::vector&lt;T&gt;</code>)</li>
          <li><code class="tt">std::map</code> (which produces types <code class="tt">std::map&lt;K, V&gt;</code>)</li>
          <li><code class="tt">std::set</code> (which produces types <code class="tt">std::set&lt;T&gt;</code>)</li>
        </ul>
      </section>

      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
          <p class="center">____________ is ________________ for type constructors.</p>
        </div>
      </section>

      <section>
        <h2 class="center">monad $\longleftrightarrow$ type constructor with <em>flattening</em></h2>
        <p class="center">Canonical example: lists</p>
        <pre class="fragment" data-fragment-index="1"><code data-trim class="language-text">
          [[1, 2, 3], 
           [4, 5, 6], 
           [7, 8, 9]]
        </code></pre>
        <p class="center fragment" data-fragment-index="2">$\downarrow$</p>
        <pre class="fragment" data-fragment-index="2"><code data-trim class="language-text">
          [1, 2, 3, 4, 5, 6, 7, 8, 9]
        </code></pre>
      </section>

      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
          <p class="center">Flattening is ________________ for type constructors.</p>
        </div>
      </section>

      <section>
        <h2 class="center">monoid $\longleftrightarrow$ <em>type</em> with <em>concatenation</em></h2>
        <ul>
          <li class="fragment" data-fragment-index="1">Lists 
            <pre><code data-trim class="language-text">
              [1, 2, 3] ++ [4, 5, 6] == [1, 2, 3, 4, 5, 6]
            </code></pre>
          </li>
          <li class="fragment" data-fragment-index="2">Strings 
            <pre><code data-trim class="language-text">
              "hello" ++ "world" == "helloworld"
            </code></pre>
          </li>
          <li class="fragment" data-fragment-index="3">Natural numbers (concatenation in unary) 
            <pre><code data-trim class="language-text">
              3 ++ 5 == 8
            </code></pre>
          </li>
        </ul>
      </section>  
      
      <section>
        <div class="vertical-center">
          <p class="center"><em>"A monad is a monoid in the category of endofunctors."</em></p>
          <p class="center">Flattening is concatenation of type constructors.</p>
        </div>
      </section>

      <section>
        <h2>Concatenation of type constructors</h2>
        <p>Concatenation of lists has type signature: $$\pplus : \texttt{List&lt;T&gt;} \times \texttt{List&lt;T&gt;} \to \texttt{List&lt;T&gt;}$$ </p>
        <p>Concatenation of the <em>type constructor</em> <code class="tt">List</code> has type signature: $$\pplus : \texttt{List&lt;List&lt;T&gt;&gt;}\to \texttt{List&lt;T&gt;} $$</p>
        <p>This is flattening!</p>
      </section>

      <section>
        <h2>Outline</h2>
        <p>Up next: What are monads and why are they useful?</p>
        <p>Later: More about categories and monoids</p>
      </section>

      <section>
        <div class="vertical-center">
          <p>In your favorite language, are the following two pieces of code equivalent (ignoring differences in running time) for any function $f : \texttt{int} \to \texttt{int}$? </p>
          <ol>
            <li><code class="tt">f(x) + f(x)</code></li>
            <li><code class="tt">f(x) * 2</code></li>
          </ol>
          <p class="answer fragment" data-fragment-index="1">No, consider the following code.</p>
          <pre class="fragment" data-fragment-index="1"><code data-trim class="language-java">
            public static int f(int x) {
              System.out.println("User executed f");
              return x + 1;
            }
          </code></pre>
        </div>
      </section>

      <section>
        <h2>Pure functions</h2>
        <p>A <em>pure</em> function is <em>deterministic</em> and has no <em>side effects</em>.</p>
        <p class="fragment">Side effects change the state of the system outside the function.</p>
        <ul class="fragment">
          <li>Input and output</li>
          <li>File system access</li>
          <li>Throwing exceptions</li>
          <li>Global variables</li>
          <li>Mutable function parameters</li>
        </ul>
      </section>

      <section>
        <h2>Functional programming</h2>
        <p><em>Functional programming</em> is a style that focuses on:</p>
        <ul>
          <li>Pure functions</li>
          <li class="fragment" data-fragment-index="1">Immutable data</li>
          <li class="fragment" data-fragment-index="2">Declarative, not imperative code</li>
          <pre class="fragment" data-fragment-index="2"><code data-trim class="language-python">
            def odd_squares(arr):
              return (arr.filter(lambda x: x % 2 == 1)
                         .map(lambda x: x ** 2))
          </code></pre>
        </ul>
        <p class="fragment" data-fragment-index="3">Functional programming should <em>feel like mathematics</em>.</p>
      </section>

      <section>
        <h2>Functional programming</h2>
        <p>People like functional programming.</p>
        <p class="fragment">Some languages are designed for it: Excel, Mathematica, Haskell</p>
        <p class="fragment">How do these languages handle side effects?</p>
        <ul>
          <li class="fragment">Excel/Mathematica: Give up on being functional languages</li>
          <li class="fragment">Haskell: Use monads!</li>
        </ul>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>Haskell uses mathematical notation for function definitions.</p>
        <p>Function application does not require parentheses.</p>
        <pre><code data-trim class="language-haskell">
          f :: Int -> Int
          f x = x + 1
        </code></pre>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>Just like in math, Haskell makes it easy to compose functions.</p>
        <pre><code data-trim class="language-haskell">
          f :: Int -> Int
          f x = x + 1

          g :: Int -> Int
          g x = x * 2

          h :: Int -> Int
          h = f . g
        </code></pre>        
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>There is a built-in identity function.</p>
        <p>It works with all types.</p>
        <p>In Haskell, we usually write <code class="tt">a</code>, <code class="tt">b</code>, etc. for generic types.</p>
        <pre><code data-trim class="language-haskell">
          id :: a -> a
          id x = x
        </code></pre>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>Haskell supports <em>pattern matching</em> in function definitions.</p>
        <pre><code data-trim class="language-haskell">
          fib :: Int -> Int
          fib 0 = 0
          fib 1 = 1
          fib n = fib (n - 1) + fib (n - 2)
        </code></pre>
        <p>(This code is not perfectly safe, it enters an infinite loop for negative values of <code class="tt">n</code>.)</p>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>You can also define functions on multiple variables.</p>
        <p>The type <code class="tt">Int -> Int -> Int</code> means <code class="tt">Int -> (Int -> Int)</code>.</p>
        <pre><code data-trim class="language-haskell">
          gcd :: Int -> Int -> Int
          gcd n 0 = n
          gcd n m = gcd m (n `mod` m)
        </code></pre>
        <p>In other words, after this definition, Haskell considers <code class="tt">gcd n</code> to be a perfectly good function with type <code class="tt">Int -> Int</code>.</p>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>Pattern matching is especially powerful for <em>algebraic data types</em>.</p>
        <pre><code data-trim class="language-haskell">
          data Shape = Circle Float | Rectangle Float Float

          area :: Shape -> Float
          area (Circle r) = pi * r * r
          area (Rectangle l w) = l * w
        </code></pre>
        <p class="fragment">In math, this is the type $\mathbb{R} + (\mathbb{R} \times \mathbb{R})$.</p>
      </section>

      <section>
        <h2>Introduction to Haskell</h2>
        <p>A <code class="tt">List</code> is a <em>recursive</em> algebraic data <em>type constructor</em>.</p>
        <pre><code data-trim class="language-haskell">
          data List a = Empty | Nonempty a (List a)

          len :: List a -> Int
          len Empty = 0
          len (Nonempty x l) = 1 + len l
        </code></pre>
        <p class="fragment">In math, we write $L(a) = 1 + (a \times L(a))$.
      </section>

      <section>
        <div class="vertical-center">
          <p>What happens when you execute the following in Java?</p>
          <pre><code data-trim class="language-java">
            List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
            System.out.println(arr.get(0));
          </code></pre>
          <p class="answer fragment" data-fragment-index="1">Throws an <code class="tt">IndexOutOfBoundsException</code>.</p>
          <pre class="fragment" data-fragment-index="2"><code data-trim class="language-java">
            List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
            System.out.println(arr.indexOf(6));
          </code></pre>
          <p class="answer fragment" data-fragment-index="3">Prints <code class="tt">-1</code> (a sentinel value).</p>
        </div>
      </section>

      <section>
        <h2>The <code class="tt">Maybe</code> type constructor</h2>
        <p>(Also called <code class="tt">Optional</code> in other languages.)</p>
        <pre><code data-trim class="language-haskell">
          data Maybe a = Nothing | Just a

          peek :: List a -> Maybe a
          peek Empty = Nothing
          peek (Nonempty x l) = Just x
        </code></pre>
        <p class="fragment">In other languages, we would likely have <code class="tt">peek :: List a -> a</code> and it would either throw an exception or return a sentinel value.</p>
      </section>

      <section>
        <h2>The <code class="tt">Writer</code> type constructor</h2>
        <p><code class="tt">Writer</code> allows you to collect text to print to the console.</p>
        <pre><code data-trim class="language-haskell">
          data Writer a = Writer a String

          addone :: Int -> Writer Int
          addone x = Writer (x + 1) "User added one. "
        </code></pre>
        <p>Although it seems trivial right now (just a fancy name for a tuple), it will become important later.</p>
      </section>

      <section>
        <h2>The <code class="tt">IO</code> type constructor</h2>
        <p>This built-in type constructor is used whenever the console is used to get input or display output.</p>
        <p><code class="tt">IO a</code> means an I/O operation that returns a value of type <code class="tt">a</code>.</p>
        <pre><code data-trim class="language-haskell">
          putStrLn :: String -> IO ()
          getLine :: IO String
        </code></pre>
        <p>Note that <code class="tt">getLine</code> is not a function!</p>
      </section>

      <section>
        <h2>Where we are</h2>
        <p>We learned about the type constructors:</p>
        <ul>
          <li><code class="tt">List</code></li>
          <li><code class="tt">Maybe</code></li>
          <li><code class="tt">Writer</code></li>
          <li><code class="tt">IO</code></li>
        </ul>
        <p>Secretly, these are all monads! That means we need to show how they <em>implement flattening</em>.</p>
        <p>Next up: Different types that implement the same functions.</p>
      </section>

      <section>
        <h2>Type classes</h2>
        <p>Type classes outline functionality that many types should share.</p>

        <p>Eventually, we'll define the <code class="tt">Monad</code> type class.</p>
        <pre><code data-trim class="language-haskell">
          class Show a where
            show :: a -> String
          
          print :: Show a => a -> IO ()
          print x = putStrLn (show x)
        </code></pre>
        </p>
      </section>

      <section>
        <h2>Type classes</h2>
        <p>We can implement the functions in a type class for various types.</p>
        <pre><code data-trim class="language-haskell">
          instance Show a => Show (List a) where
            show Empty = ""
            show (Nonempty x Empty) = show x
            show (Nonempty x l) = show x ++ ", " ++ show l
          
          main :: IO ()
          main = print (Nonempty 3 (Nonempty 8 Empty))
        </code></pre>
      </section>

      <section>
        <h2>Functors</h2>
        <p>We defined earlier that endofunctors are just type constructors.</p>
        <p>Formally, an (endo)functor must also be an instance of the <code class="tt">Functor</code> type class.</p>
        <pre><code data-trim class="language-haskell">
          class Functor F where
            fmap :: (a -> b) -> F a -> F b
        </code></pre>
        <p>The meaning of <code class="tt">fmap f</code> is that it applies <code class="tt">f</code> to each element inside the container.</p>
      </section>

      <section>
        <h2>Functors</h2>
        <pre><code data-trim class="language-haskell">
          instance Functor Maybe where
            fmap f Nothing = Nothing
            fmap f (Just x) = Just (f x)
        </code></pre>
        <div class="column">
          <div class="fragment" data-fragment-index="1"><span><code class="tt">f</code> ‚ù§Ô∏è <code class="tt">x</code></span></div>
          <div class="divider fragment" data-fragment-index="2"></div>
          <div class="fragment" data-fragment-index="2"><span><code class="tt">f</code> üò¢</span><span class="small-box"><code class="tt">x</code></span></div>
          <div class="divider fragment" data-fragment-index="3"></div>
          <div class="fragment" data-fragment-index="3"><span><code class="tt">fmap</code> ü§ù <code class="tt">f</code></span><span class="small-box"><code class="tt">x</code></span></div>
          <div class="divider fragment" data-fragment-index="4"></div>
          <div class="fragment" data-fragment-index="4"><span class="small-box"><span><code class="tt">f</code> ‚ù§Ô∏è <code class="tt">x</code></span></span></div>
        </div> 
      </section>

      <section>
        <h2>Functors</h2>
        <pre><code data-trim class="language-haskell">
          instance Functor Writer where
            fmap f Writer x s = Writer (f x) s
        </code></pre>
        <pre class="fragment"><code data-trim class="language-haskell">
          instance Functor List where
            fmap f Empty = Empty
            fmap f (Nonempty x l) = Nonempty (f x) (fmap f l)
        </code></pre>
      </section>

      <!-- <section>
        <h2>Functors </h2>
        <p>Some type constructors cannot be reasonably made into functors.</p>
        <pre class="fragment" data-fragment-index="1"><code data-trim class="language-haskell">
          data SelfFunc a = SelfFunc (a -> a)
        </code></pre>
        <p class="fragment" data-fragment-index="2">We would need <code class="tt">fmap :: (a -> b) -> SelfFunc a -> SelfFunc b</code>.</p> 
        <p class="fragment" data-fragment-index="3">There is no way to take an <code class="tt">a -> a</code> and turn it into <code class="tt">b -> b</code> by applying <code class="tt">f :: a -> b</code> to it.</p>
        <p class="fragment" data-fragment-index="4">Functors can be thought of as <em>containers</em>.</p>
      </section> -->

      <section>
        <h2>When <code class="tt">fmap</code> is not enough</h2>
        <p>Imagine that <code class="tt">f</code> wants to change <code class="tt">x</code> into <code class="tt">y</code> and put it in a box, but <code class="tt">x</code> is already in 2 boxes. One option is:</p> 
        <div class="column overlap">
          <div class="fragment fade-in-then-out" data-fragment-index="1">
            <span><code class="tt">f</code> üò≠</span>
            <span class="big-box"><span class="box">
              <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="2">
            <span><code class="tt">fmap</code> ü§ù <code class="tt">f</code></span>
            <span class="big-box"><span class="box">
              <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="3">
            <span class="big-box">
              <span><code class="tt">f</code> üò¢</span> 
              <span class="box">
                <code class="tt">x</code>
              </span>
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="4">
            <span class="big-box">
              <span><code class="tt">fmap</code> ü§ù <code class="tt">f</code></span> 
              <span class="box">
                <code class="tt">x</code>
              </span>
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="5">
            <span class="big-box"><span class="box">
              <code class="tt">f</code> üòà <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in" data-fragment-index="6">
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">y</code>
                </span>
              </span>
            </span>
          </div>
        </div>
        <p class="fragment" data-fragment-index="7">But the next time, <code class="tt">f</code> will have to get help from <code class="tt">fmap</code> 3 times!</p>
      </section>

      <section>
        <h2>Monads</h2>
        <p>A monad is a functor that also supports flattening. Formally,</p>
        <pre><code data-trim class="language-haskell">
          class Functor m => Monad m where
            join :: m (m a) -> m a
            return :: a -> m a
        </code></pre>
        <p>Haskell prefers the word <code class="tt">join</code> over <code class="tt">flatten</code>, but the meaning is the same. </p>
        <p>The function <code class="tt">return</code> is less important, it just puts a value into the container.</p>
      </section>

      <section>
        <h2>The <code class="tt">Maybe</code> monad</h2>
        <pre><code data-trim class="language-haskell">
          instance Monad Maybe where
            join (Just (Just x)) = Just x
            return x = Just x
        </code></pre>

        <div class="column overlap">
          <div class="fragment fade-in-then-out" data-fragment-index="1">
            <span><code class="tt">f</code> üò≠</span>
            <span class="big-box"><span class="box">
              <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="2">
            <span><code class="tt">join</code> ‚ú®</span>
            <span class="big-box"><span class="box">
              <code class="tt">x</code>
            </span></span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="3">
            <span class="box">
              <code class="tt">x</code>
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="4">
            <span><code class="tt">fmap</code> ü§ù <code class="tt">f</code></span> 
            <span class="box">
              <code class="tt">x</code>
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="5">
            <span class="box">
              <code class="tt">f</code> üòà <code class="tt">x</code>
            </span>
          </div>

          <div class="fragment fade-in" data-fragment-index="6">
            <span class="box"><span class="small-box">
              <code class="tt">y</code> 
            </span></span>
          </div>
        </div>

        <p class="fragment" data-fragment-index="7">In code, we can now do <code class="tt">fmap f . join</code>.</p>
      </section>


      <section>
        <h2>The <code class="tt">Writer</code> monad</h2>
        <pre><code data-trim class="language-haskell">
          instance Monad Writer where
            join (Writer (Writer x s1) s2) = Writer x (s1 ++ s2)
            return x = Writer x ""
        </code></pre>
        <div class="column">
          <div class="fragment" data-fragment-index="1">
            <span><code class="tt">join</code> ‚ú®</span>
            <span class="box"><span class="small-box">
              <code class="tt">x</code> üìï
            </span>üìó</span>
          </div>

          <div class="divider fragment" data-fragment-index="2"></div>

          <div class="fragment" data-fragment-index="2">
            <span class="small-box">
              <code class="tt">x</code> üìï üìó
            </span>
          </div>
        </div>
      </section>

      <section>
        <h2>The <code class="tt">Writer</code> monad</h2>
        <pre><code data-trim class="language-haskell">
          f :: Int -> Writer Int
          f x = Writer (x + 1) "Applied f. "

          g :: Int -> Writer Int
          g x = Writer (x * 2) "Applied g. "

          h :: Int -> Writer Int
          h x = Writer (x - 1) "Applied h. "
        </code></pre>
        <p>We want the "composition" <code class="tt">f . g . h</code>, but that is not possible.</p>
      </section>

      <section>
        <h2>The <code class="tt">Writer</code> monad</h2>
        <p>Instead, we can use <code class="tt">fmap</code> and <code class="tt">join</code>!</p>
        <pre><code data-trim class="language-haskell">
          composed :: Int -> Writer Int
          composed = join . fmap f . join . fmap g . h
        </code></pre>
        <p class="fragment" data-fragment-index="1">Haskell provides a <em>reverse fish</em> operator to make this more concise:</p>
        <pre class="fragment" data-fragment-index="1"><code data-trim class="language-haskell">
          (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
          (f <=< g) = join . fmap f . g 
          composed = f <=< g <=< h
        </code></pre>
      </section>

      <section>
        <h2>The <code class="tt">Writer</code> monad</h2>
        <p>Reverse fish composition fulfills the same need as standard composition with side effects, but remains pure. Recall that:</p>
        <pre><code data-trim class="language-haskell">
          f x = Writer (x + 1) "Applied f. "
          g x = Writer (x * 2) "Applied g. "
          h x = Writer (x - 1) "Applied h. "
        </code></pre>
        <p>Then <code class="tt">f <=< g <=< h</code> is equivalent to:</p>
        <pre class="fragment"><code data-trim class="language-haskell">
          composed x = Writer (((x - 1) * 2) + 1) 
                       "Applied h. Applied g. Applied f. "
        </code></pre>
      </section>

      <section>
        <h2><code class="tt">do</code> notation</h2>
        <p>Another way to use monads in Haskell is <code class="tt">do</code> notation.</p>
        <pre><code data-trim class="language-haskell">
          composed :: Int -> Writer Int
          composed x = do
            y1 <- h x 
            y2 <- g y1 
            y3 <- f y2
            return y3 
        </code></pre>
        <p>Superficially, it now looks a lot like other languages!</p>
      </section>

      <section>
        <h2><code class="tt">do</code> notation</h2>
        <p>To explain <code class="tt">do</code> notation, you will will first need to understand <em>lambda functions</em>.</p>

        <p>A lambda function is just an unnamed function. It has the following syntax:</p>

        <pre><code data-trim class="language-haskell">
          squareAll :: List Int -> List Int
          squareAll list = fmap (\x -> x * x) list
        </code></pre>
      </section>

      <section>
        <h2><code class="tt">do</code> notation</h2>
        <p>Let <code class="tt">f :: a -> m a</code> for some <code class="tt">Monad m</code> and type <code class="tt">a</code>. Then,</p>
        <pre><code data-trim class="language-haskell">
          g x = do
            y <- f x
            ...
        </code></pre>
        <p>is defined to mean:</p>
        <pre><code data-trim class="language-haskell">
          g = ((\y -> ...) <=< f)
        </code></pre>
      </section>

      <section>
        <h2><code class="tt">do</code> notation</h2>
        <pre><code data-trim class="language-haskell">
          h x = do
            y <- f x
            z <- g y
            return z
        </code></pre>
        <pre><code data-trim class="language-haskell">
          h = (\y -> ((\z -> return z) <=< g) y) <=< f
            = (\y -> (return <=< g) y) <=< f
            = return <=< g <=< f
            = g <=< f
        </code></pre>
      </section>

      <section>
        <h2><code class="tt">do</code> notation in I/O</h2>
        <pre><code data-trim class="language-haskell">
          main = do
            print "Enter name:"
            name <- getLine
            print ("Hello, " ++ name)
        </code></pre>

        <pre><code data-trim class="language-haskell">
          main = ((\_ -> (
                    (\name -> 
                      print ("Hello, " ++ name)
                    ) <=< (\_ -> getLine)) ()
                  ) <=< (\_ -> print "Enter name:")) ()
        </code></pre>
      </section>

      <section>
        <h2>Where we are</h2>
        <p>We learned about functors and monads.</p>
        <ul>
          <li><code class="tt">fmap</code> helps functions jump into containers</li>
          <li><code class="tt">join</code> flattens out nested containers</li>
          <li>Monads capture side effects</li>
          <li><code class="tt"><=<</code> and <code class="tt">do</code> make it easy to compose monadic functions</li>
        </ul>
        <p class="fragment">Next up: categories and monoids</p>
      </section>

      <section>
        <h2>Functor laws</h2>
        <p>Our  <em>category</em> is called <code class="tt">*</code>, and we said that an (endo)functor is a type constructor <code class="tt">F :: * -> *</code> that supports <code class="tt">fmap</code>.</p>

        <p class="fragment" data-fragment-index="1">Formally, <code class="tt">fmap</code> must also satisfy the following:</p>
        <ul class="fragment" data-fragment-index="1">
          <li>Identity law: </li>
          <div class="center"><code class="tt">fmap id == id</code></div>
          <li>Composition law: If <code class="tt">h == f . g</code>, then</li>
          <div class="center"> <code class="tt">fmap h == fmap f . fmap g</code></div>
        </ul>
        
      </section>
<!-- 
      <section>
        <h2>Functor laws</h2>
        <div class="center"><code class="tt">fmap (f . g) == fmap f . fmap g</code></div>
        <div class="column">
          <div class="fragment" data-fragment-index="1">
            <span><code class="tt">fmap</code> ü§ù <code class="tt">(f . g)</code></span>
            <span class="small-box">
              <code class="tt">x</code>
            </span>
          </div>

          <div class="divider fragment" data-fragment-index="2"></div>

          <div class="fragment" data-fragment-index="2">
            <span class="small-box">
              <span><code class="tt">(f . g) x</code></span>
            </span>
          </div>

          <div class="divider fragment" data-fragment-index="3"></div>

          <div class="fragment" data-fragment-index="3">
            <span class="small-box">
              <span><code class="tt">f g x</code></span>
            </span>
          </div>
        </div> 
        <div class="column">
          <div class="fragment" data-fragment-index="4">
            <span><code class="tt">fmap</code> ü§ù <code class="tt">g</code></span>
            <span class="small-box">
              <code class="tt">x</code>
            </span>
          </div>

          <div class="divider fragment" data-fragment-index="5"></div>

          <div class="fragment" data-fragment-index="5">
            <span class="small-box">
              <span><code class="tt">g x</code></span>
            </span>
          </div>

          <div class="divider fragment" data-fragment-index="6"></div>

          <div class="fragment" data-fragment-index="6">
            <span><code class="tt">fmap</code> ü§ù <code class="tt">f</code></span>
            <span class="small-box">
              <code class="tt">g x</code>
            </span>
          </div>

          <div class="divider fragment" data-fragment-index="7"></div>

          <div class="fragment" data-fragment-index="7">
            <span class="small-box">
              <span><code class="tt">f g x</code></span>
            </span>
          </div>
        </div> 
      </section> -->

      <section>
        <h2>Monad laws</h2>
        <p>Monads are required to satisfy:</p>
        <ul>
          <li>Identity laws (acting on <code class="tt">m a</code>):
            <ul>
              <li>Box from outside: <code class="tt">join . return == id</code></li>
              <div class="column overlap">
                <div class="fragment fade-in-then-out" data-fragment-index="1">
                  <span class="box">
                    <code class="tt">x</code> üìï
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="2">
                  <span><code class="tt">return</code> üòà</span>
                  <span class="box">
                    <code class="tt">x</code> üìï
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="3">
                  <span class="big-box">
                    <span class="box">
                      <code class="tt">x</code> üìï
                    </span>
                  </span>
                </div>
                
                <div class="fragment fade-in-then-out" data-fragment-index="4">
                  <span><code class="tt">join</code> ‚ú® </span>
                  <span class="big-box">
                    <span class="box">
                      <code class="tt">x</code> üìï
                    </span> 
                  </span>
                </div>

                <div class="fragment fade-in" data-fragment-index="5">
                  <span class="box">
                    <code class="tt">x</code> üìï
                  </span>
                </div>
              </div>
              <li class="fragment fade-in" data-fragment-index="6">Box from inside: <code class="tt">join . fmap return == id</code></li>
            </ul>
          </li>
        </ul>
      </section>

      <section>
        <h2>Monad laws</h2>
        <p>Monads are required to satisfy:</p>
        <ul>
          <li>Identity laws (acting on <code class="tt">m a</code>):
            <ul>
              <li>Box from outside: <code class="tt">join . return == id</code></li>
              <li>Box from inside: <code class="tt">join . fmap return == id</code></li>
              <div class="column overlap">
                <div class="fragment fade-in-then-out" data-fragment-index="1">
                  <span class="box">
                    <code class="tt">x</code> üìï
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="2">
                  <span><code class="tt">fmap</code> ü§ù <code class="tt">return</code></span>
                  <span class="box">
                    <code class="tt">x</code> üìï
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="3">
                  <span class="box">
                    <span><code class="tt">return</code> üòà <code class="tt">x</code> üìï</span>
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="4">
                  <span class="box">
                    <span class="small-box">
                      <code class="tt">x</code> üìï
                    </span>
                  </span>
                </div>
                
                <div class="fragment fade-in-then-out" data-fragment-index="5">
                  <span><code class="tt">join</code> ‚ú® </span>
                  <span class="box">
                    <span class="small-box">
                      <code class="tt">x</code> üìï
                    </span>
                  </span>
                </div>
                
                <div class="fragment fade-in-then-out" data-fragment-index="6">
                  <span class="small-box">
                    <code class="tt">x</code> üìï
                  </span>
                </div>

                <div class="fragment fade-in-then-out" data-fragment-index="6">
                  <span class="big-box" style="visibility: hidden;"></span>
                </div>
              </div>
            </ul>
          </li>
        </ul>
      </section>

      <section>
        <h2>Monad laws</h2>
        <ul>
          <li>Associativity law (acting on <code class="tt">m (m (m a))</code>): </li>
          <div class="center"><code class="tt">join . join == join . fmap join </code></div>
        </ul>
        <div class="column overlap">
          <div class="fragment fade-in-then-out" data-fragment-index="1">
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> üìï
                </span> üìó
              </span> üìò
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="2">
            <span><code class="tt">join</code> ‚ú® </span>
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> üìï
                </span> üìó
              </span> üìò
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="3">
            <span class="box">
              <span class="small-box">
                <code class="tt">x</code> üìï
              </span> üìó üìò
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="4">
            <span><code class="tt">join</code> ‚ú® </span>
            <span class="box">
              <span class="small-box">
                <code class="tt">x</code> üìï
              </span> üìó üìò
            </span>
          </div>
          
          <div class="fragment fade-in-then-out" data-fragment-index="5">
            <span class="small-box">
              <code class="tt">x</code> üìï üìó üìò
            </span>
          </div>
          
          <div class="fragment fade-in-then-out" data-fragment-index="6">
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> üìï
                </span> üìó
              </span> üìò
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="7">
            <span><code class="tt">fmap</code> ü§ù <code class="tt">join</code></span>
            <span class="big-box">
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> üìï
                </span> üìó
              </span> üìò
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="8">
            <span class="big-box">
              <span><code class="tt">join</code> ‚ú® </span>
              <span class="box">
                <span class="small-box">
                  <code class="tt">x</code> üìï
                </span> üìó
              </span> üìò
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="9">
            <span class="big-box">
                <span class="small-box">
                  <code class="tt">x</code> üìï üìó
              </span> üìò
            </span>
          </div>

          <div class="fragment fade-in-then-out" data-fragment-index="10">
            <span><code class="tt">join</code> ‚ú® </span>
            <span class="big-box">
                <span class="small-box">
                  <code class="tt">x</code> üìï üìó
              </span> üìò
            </span>
          </div>

          <div class="fragment fade-in" data-fragment-index="11">
            <span class="small-box">
              <code class="tt">x</code> üìï üìó üìò
            </span> 
          </div>
        </div>

        <p class="fragment center" data-fragment-index="12">"Joining outer first is the same as joining inner first."</p>
      </section>

      <section>
        <h2>Monoid laws</h2>
        <p>The monoid laws are exactly the same as the monad laws, with outside/inside replace with left/right!</p>
        <pre><code data-trim class="language-haskell">
          class Monoid m where
            (++) :: m -> m -> m
            empty :: m
        </code></pre>
        <ul>
          <li>Identity laws: <code class="tt">empty ++ x == x</code> and<code class="tt">x ++ empty == x</code></li>
          <li>Associativity law: <code class="tt">(x ++ y) ++ z == x ++ (y ++ z)</code></li>
        </ul>
      </section>

      <section>
        <h2>Final takeaways</h2>
        <ul>
          <li>Functional programming languages have functions return monadic types instead of producing side effects.</li>
          <li>The structure of a monad lets you easily compose such functions.</li>
          <li>Monoids in the category of endofunctors is a correct but terrible definition.</li>
        </ul>
      </section>

      <!-- <section>
        <h2>Natural transformations</h2>
        <p>Recall <code class="tt">peek :: List a -> Maybe a</code>.</p>

        <p>A function between functors like <code class="tt">peek</code> is called a <em>natural transformation</em> if it satisfies for all <code class="tt"> f :: a -> b</code>:</p>
        <ul>
          <li><code class="tt">fmap f . peek == peek . fmap f</code></li>
        </ul>
        <p>In other words, <code class="tt">peek</code> can repackage, rearrange, delete, or duplicate data, but not change it.</p>
        
      </section>

      <section>
        <h2>Natural transformations</h2>
        <p class="theorem"><strong>Theorem.</strong> (Wadler 1989) All functions <code class="tt">eta :: F a -> G a</code> definable in Haskell are natural transformations.</p></p>
        <p>This is not true in math, because $\eta$ can condition on the type $a$.</p>
        <p>Let $\eta$</p>
      </section> -->
      <!-- <section>
        <h2>Overview</h2>
        <p>Our main contribution is an equivalence:</p>
        <p class="center"><strong>e-graphs $\leftrightarrow$ (cyclic) monotone circuits</strong></p>
        <p class="fragment" data-fragment-index="1">This allows us to:</p> 
        <ul>
          <li class="fragment" data-fragment-index="1">Apply <strong>[KTX17]</strong> to efficiently solve extraction, parameterized by treewidth.</li> 
          <li class="fragment" data-fragment-index="2">More easily <strong>simplify e-graphs</strong>, which significantly reduces treewidth.</li>
        </ul>

        <p class="fragment" data-fragment-index="3">The algorithm is very similar to <strong>[GLP24]</strong>, which you just saw.</p>

        <table class="citations">
          <tr class="fragment" data-fragment-index="1">
            <td>[KTX17]</td>
            <td>Iyad Kanj, Dimitrios M. Thilikos, and Ge Xia. <em>On the parameterized complexity of monotone and antimonotone weighted circuit satisfiability.</em></td>
          </tr>
          <tr class="fragment" data-fragment-index="3">
            <td>[GLP24]</td>
            <td>Amir Kafshdar Goharshady, Chun Kit Lam, and Lionel Parreaux. <em>Fast and Optimal Extraction for Sparse Equality Graphs.</em></td>
          </tr>
        </table>
      </section>

      <section>
        <h2>Monotone circuits</h2>
        <p>A <strong>monotone circuit</strong> is a circuit with only AND and OR gates.</p>
        <div class="column pad-top-bottom">
          <div class="fragment">
            <p>e-node $\leftrightarrow$ all children true $\leftrightarrow$ AND</p>
            <img width="766px" src="node-and.svg">
          </div>
          <div class="fragment">
            <p>e-class $\leftrightarrow$ at least one child true $\leftrightarrow$ OR</p>
            <img width="766px" src="class-or.svg">
          </div>
        </div>
      </section>

      <section>
        <div class="column vertical-center">
          <img width="383px" src="egraph-example.svg">
          <p class="fragment" data-fragment-index="1">$\longrightarrow$</p> 
          <img class="fragment" data-fragment-index="1" width="713px" src="egraph-converted.svg">
        </div>
      </section>

      <section>
        <h2>What about cycles?</h2>
        <div class="column">
          <div style="width: 800px; height: 550px; display: flex; flex-direction: column; align-items: center; justify-content: center">
            <img class="fragment" data-fragment-index="1" width="524px" src="cyclic-circuit.svg">
          </div>
          <table class="fragment" data-fragment-index="2">
            <tr class="fragment" data-fragment-index="2">
              <th>$x$</th>
              <th>old output</th>
              <th class="left-double">new output</th>
            </tr>
            <tr class="fragment" data-fragment-index="3">
              <td>0</td>
              <td>0</td>
              <td class="left-double">0</td>
            </tr>
            <tr class="fragment" data-fragment-index="4">
              <td>0</td>
              <td>1</td>
              <td class="left-double">0</td>
            </tr>
            <tr class="fragment" data-fragment-index="5">
              <td>1</td>
              <td>0</td>
              <td class="left-double">0</td>
            </tr>
            <tr class="fragment" data-fragment-index="6">
              <td>1</td>
              <td>1</td>
              <td class="left-double">1</td>
            </tr>
          </table>
        </div>
        <p class="fragment">But e-graphs researchers never have to think about this. Why not?</p>

      </section>
      <section>
        <h2>What about cycles?</h2>
        <div class="column">
          <div style="width: 800px; height: 550px; display: flex; flex-direction: column; align-items: center; justify-content: center">
            <img width="744px" src="cyclic-circuit2.svg">
          </div>
          <table>
            <tr>
              <th>$x$</th>
              <th>old output</th>
              <th class="left-double">new output</th>
            </tr>
            <tr>
              <td>0</td>
              <td>0</td>
              <td class="left-double">0</td>
            </tr>
            <tr>
              <td>0</td>
              <td>1</td>
              <td class="left-double">0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>0</td>
              <td class="left-double">0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>1</td>
              <td class="left-double">1</td>
            </tr>
          </table>
        </div>
        <p>But e-graphs researchers never have to think about this. Why not?</p>
      </section>
      <section>
        <h2>What about cycles?</h2>
        <div class="column">
          <div style="width: 800px; height: 550px; display: flex; flex-direction: column; align-items: center; justify-content: center">
            <img width="744px" src="cyclic-circuit2.svg">
            <img width="203px" src="tiny.svg">
          </div>
          <table>
            <tr>
              <th>$x$</th>
              <th>old output</th>
              <th class="left-double">new output</th>
            </tr>
            <tr>
              <td>0</td>
              <td>0</td>
              <td class="left-double">0</td>
            </tr>
            <tr>
              <td>0</td>
              <td>1</td>
              <td class="left-double">0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>0</td>
              <td class="left-double">0</td>
            </tr>
            <tr>
              <td>1</td>
              <td>1</td>
              <td class="left-double">1</td>
            </tr>
          </table>
        </div>
        <p>But e-graphs researchers never have to think about this. Why not?</p>
        <div class="fixed">
          <p class="fragment" style="top: 305px; left: 990px;">‚úÖ</p>
          <p class="fragment" style="top: 554px; left: 990px;">‚úÖ</p>
          <p class="fragment" style="top: 388px; left: 990px;">‚ùå</p>
          <p class="fragment" style="top: 471px; left: 990px;">‚ùå</p>
        </div>
        <ul>
          <li class="fragment">To find the minimum cost extraction, only need to consider  <strong>minimal</strong> solutions.</li>
          <li class="fragment">For this particular circuit construction, every choice of minimally satisfying inputs (what to extract) has a unique way to set the rest of the circuit.</li>
        </ul>
      </section>
      <section>
        <h2>Converting to circuits</h2>
        <p>To convert an e-graph $G$ to a circuit $C$:</p>
        <ul>
          <li>Replace every e-class with an OR gate.</li>
          <li>Replace every e-node with an AND gate and a variable connected to it.</li>
        </ul>
        <div class="theorem fragment">
          <p><b>Observation.</b> After this conversion from e-graph to circuit, there is a bijection</p>
          <p class="center"><strong>minimal extractions</strong> of $G$ $\leftrightarrow$ <strong>minimal satisfying solutions</strong> of $C$.</p>
          <p>This bijection preserves acyclicity.</p>
          <p>(acyclic: extraction has no self-dependencies, circuit evaluation has no 1-cycles)</p>
        </div>
        <p class="fragment">$\implies$ Extraction is equivalent to <strong>weighted monotone circuit SAT</strong>!</p>
      </section>
      <section>
        <h2>Minimum weight monotone circuit SAT</h2>
        <p>[KTX17] already solved this, albeit stated only for circuits that do not have cycles.</p>
        <p class="theorem"><b>Proposition 4.7 in [KTX17].</b> Let $C$ be a monotone circuit <strong>(with no cycles)</strong> and $G$ be the underlying undirected graph with $n$ nodes. If a tree decomposition for $G$ and treewidth $k$ is given, then a minimum weight satsifying assignment of $C$ can be computed in time $2^{O(k)}\text{poly}(n, k)$.</p>
        <p class="fragment" data-fragment-index="1">The algorithm works unchanged for circuits with cycles, if we allow cyclic extraction!</p>
        <ul class="fragment" data-fragment-index="1">
          <li>Intuition: The undirected graph $G$ already "forgot" whether $C$ is a DAG.</li>
        </ul>
        <p class="fragment">For acyclic extraction, can maintain the transitive closure of the subgraph of 1-edges to make sure no 1-cycles are formed, achieving $2^{O(k^2)}\text{poly}(n, k)$.</p> 
      </section>

      <section>
        <div class="column vertical-center">
          <img width="713px" src="egraph-converted.svg">
          <p class="fragment" data-fragment-index="1">$\longrightarrow$</p> 
          <img class="fragment" data-fragment-index="1" width="701px" src="simplified.svg">
        </div>
      </section>

      <section>
        <h2>Circuit simplification</h2>
        <p>E-graph simplification before extraction has been used with ILP (i.e. see <span class="mono">https://github.com/egraphs-good/extraction-gym/pull/16)</span></p>
        <p class="fragment" data-fragment-index="1">With circuits, we can leverage <strong>existing circuit minimization tools that support sequential circuits</strong>*.</p>
        <ul class="fragment">
          <li>These preserve the whole $\{\text{input}\} \times \{\text{old state}\} \to \{\text{new state}\}$ table.</li>
          <li>Takes care of simplifications like the previous slide.</li>
        </ul>
        <p class="fragment">But we only care about minimal satisfying solutions, sometimes acyclic.</p>
        <ul>
          <li class="fragment">Can write <strong>additional specialized rules</strong> to take advantage of this!</li>
        </ul>
        <table class="citations">
          <tr class="fragment" data-fragment-index="1">
            <td style="width: 0;">*</td>
            <td>Need to restrict to the procedures that preserve monotonicity.</td>
          </tr>
        </table>
      </section>

      <section>
        <h2>Custom simplification rules</h2>
        <p>Because we are only interested in <strong>minimal</strong> extractions:</p>
        <div class="column vertical-center">
          <img class="fragment" data-fragment-index="1" width="701px" src="simplified.svg">
          <p class="fragment" data-fragment-index="2">$\longrightarrow$</p> 
          <img class="fragment" data-fragment-index="2" width="508px" src="simplified2.svg">
        </div>
      </section>

      <section>
        <h2>Custom simplification rules</h2>
        <p>If we are only interested in <strong>acyclic extractions:</strong></p>
        <div class="vertical-center">
          <img class="fragment" width="1022px" src="remove-or-loop.svg">
        </div>
        <div class="fixed">
          <p class="fragment" style="top: 585px; left: 1160px;">$1$</p>
          <p class="fragment" style="top: 605px; left: 920px;">$1$</p>
          <p class="fragment" style="top: 685px; left: 620px;">$1$</p>
          <p class="fragment" style="top: 685px; left: 1430px;">$1$</p>
        </div>
      </section>
      <section data-auto-animate>
        <h2>Custom simplification rules</h2>
        <p>If we are only interested in <strong>acyclic extractions:</strong></p>
        <div class="vertical-center">
          <img width="1022px" src="remove-or-loop.svg">
        </div>
        <div class="fixed">
          <p style="top: 585px; left: 1160px;">$0$</p>
          <p class="fragment" data-fragment-index="1" style="top: 350px; left: 980px; width: 800px;">delete this gate and all out-neighbors that are AND gates recursively</p>
          <img class="fragment" data-fragment-index="1" width="164px" style="position: relative; top: 508px; left: 980px;" src="x.svg"> 
        </div>
      </section>
      <section data-auto-animate>
        <h2>Custom simplification rules</h2>
        <p>If we are only interested in <strong>acyclic extractions:</strong></p>
        <div class="vertical-center">
          <img width="1022px" src="remove-or-loop.svg">
          <p class="center">$\downarrow$</p> 
          <img width="1022px" src="remove-or-loop2.svg">
        </div>
      </section>

      <section>
        <h2>Simplification results</h2>
        <div class="column">
          <div>
            <p >We applied several ad-hoc rules like this to a test set of e-graphs used with egg. Depending on which applications the e-graphs came from, we observed:</p>
            <ul>
              <li>Up to 65% reduction in treewidth.</li>
              <li>42-97% reduction in $|V|$.</li>
              <li>57-96% reduction in $|E|$.</li>
            </ul>
            <p>A more systematic approach might improve this further.</p>
          </div>
          <img width="800px" src="eggcc-bril.png">
          
        </div>
        
      </section>

      <section>
        <h2>Open directions</h2>
        <ul>
          <li class="fragment">Can the treewidth-based extraction algorithm be adapted to support more general cost functions?</li>
          <ul>
            <li class="fragment">Cost of an e-node is often written as a function of the cost of children.</li>
            <li class="fragment">Current algorithm (both [GLP24] and us) has no way to deal with the cost of a yet-unknown child.</li>
          </ul>
          <li class="fragment">How much simplification can you achieve if you actually adapted modern circuit simplification software that is used in practice?</li>
          <li class="fragment">Can we find more applications of the connection between e-graphs and circuits?</li>
        </ul>
        <p class="fragment center pad-top-bottom">Thank you!</p>
      </section> -->
    </div>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/reveal.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/plugin/math/math.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.2/plugin/markdown/markdown.js"></script>
  <script src="https://unpkg.com/reveal.js/plugin/highlight/highlight.js"></script>

  <script>
    Reveal.initialize({
      controls: false,
      controlsTutorial: false,
      transition: 'fade',
      plugins: [RevealMath.KaTeX, RevealMarkdown, RevealHighlight],
      width: 1800,
      height: 1080,
      history: true,
      slideNumber: true,
      katex: {
        macros: {
          "\\pplus": "+\\!\\!+",
        }
      }
      
    });

    Reveal.configure({ pdfSeparateFragments: false });

  </script>

</body>

</html>